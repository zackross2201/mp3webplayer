<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced MP3 Player</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- jsmediatags library for reading MP3 metadata -->
    <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>
    <style>
        /* Base styles for the progress bar and volume slider thumbs */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.4);
            transition: background 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.4);
            transition: background 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        /* Set Inter font */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease;
            /* Adjusted for more top alignment */
            align-items: flex-start; /* Align content to the top */
            padding-top: 2rem; /* Add some padding at the top */
            min-height: 100vh; /* Ensure body takes full viewport height for centering logic */
        }

        /* Styles for scrollbar in playlist for better aesthetics */
        #playlist-items::-webkit-scrollbar,
        #create-playlist-songs::-webkit-scrollbar,
        #playlist-detail-songs::-webkit-scrollbar {
            width: 8px;
        }

        #playlist-items::-webkit-scrollbar-track,
        #create-playlist-songs::-webkit-scrollbar-track,
        #playlist-detail-songs::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 10px;
        }

        #playlist-items::-webkit-scrollbar-thumb,
        #create-playlist-songs::-webkit-scrollbar-thumb,
        #playlist-detail-songs::-webkit-scrollbar-thumb {
            background: var(--text-muted);
            border-radius: 10px;
        }

        #playlist-items::-webkit-scrollbar-thumb:hover,
        #create-playlist-songs::-webkit-scrollbar-thumb:hover,
        #playlist-detail-songs::-webkit-scrollbar-thumb:hover {
            background: var(--text-light);
        }

        /* Theme Variables (Default Light) */
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f1f5f9; /* slate-100 */
            --text-primary: #1f2937; /* gray-900 */
            --text-secondary: #4b5563; /* gray-700 */
            --text-muted: #9ca3af; /* gray-400 */
            --border-color: #e5e7eb; /* gray-200 */
            --accent-main: #8B5CF6; /* purple-500 (default static) */
            --accent-hover: #7C3AED;
            --accent-bg-light: #f3e8ff;
            --accent-rgb: 139, 92, 246;
            --progress-track: #e0bbff;
        }

        /* Dark Mode Variables */
        body.dark-mode {
            --bg-primary: #1a202c; /* dark gray */
            --bg-secondary: #2d3748; /* darker gray */
            --text-primary: #f7fafc; /* light gray */
            --text-secondary: #a0aec0; /* medium gray */
            --text-muted: #cbd5e0; /* lighter gray */
            --border-color: #4a5568; /* darker gray border */
            --accent-main: #9F7AEA; /* slightly lighter purple for visibility */
            --accent-hover: #B794F4;
            --accent-bg-light: #4c2c77;
            --accent-rgb: 159, 122, 234;
            --progress-track: #5d3f82;
        }

        /* Apply theme variables */
        .player-container {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
            max-height: 90vh; /* Ensure the player container itself doesn't exceed viewport height */
        }
        .text-gray-900 { color: var(--text-primary); }
        .text-gray-800 { color: var(--text-primary); }
        .text-gray-600 { color: var(--text-secondary); }
        .text-gray-500 { color: var(--text-secondary); }
        .text-gray-700 { color: var(--text-secondary); }

        .tab-button.active {
            background-color: var(--accent-main);
            color: white;
        }
        .tab-button:not(.active):hover {
            background-color: var(--bg-secondary);
        }

        .bg-purple-600 { background-color: var(--accent-main); }
        .hover\:bg-purple-700:hover { background-color: var(--accent-hover); }
        .text-purple-600 { color: var(--accent-main); }
        .hover\:text-purple-600:hover { color: var(--accent-hover); }
        .focus\:ring-purple-500:focus { --tw-ring-color: var(--accent-main); }
        .bg-purple-200 { background-color: var(--progress-track); }
        .bg-purple-100 { background-color: var(--accent-bg-light); }
        .text-purple-800 { color: var(--accent-main); } /* Use accent-main for strong text too */

        /* Custom accent colors (static presets) */
        .accent-purple { --accent-main: #8B5CF6; --accent-hover: #7C3AED; --accent-bg-light: #f3e8ff; --accent-rgb: 139, 92, 246; --progress-track: #e0bbff;}
        .accent-blue { --accent-main: #3B82F6; --accent-hover: #2563EB; --accent-bg-light: #DBEAFE; --accent-rgb: 59, 130, 246; --progress-track: #BFDBFE;}
        .accent-green { --accent-main: #10B981; --accent-hover: #059669; --accent-bg-light: #D1FAE5; --accent-rgb: 16, 185, 129; --progress-track: #A7F3D0;}
        .accent-red { --accent-main: #EF4444; --accent-hover: #DC2626; --accent-bg-light: #FEE2E2; --accent-rgb: 239, 68, 68; --progress-track: #FECACA;}

        /* Apply these generic classes to elements that should adapt to accent colors */
        .apply-accent-color {
            background-color: var(--accent-main);
        }
        .apply-accent-hover:hover {
            background-color: var(--accent-hover);
        }
        .apply-accent-text {
            color: var(--accent-main);
        }
        .apply-accent-text-hover:hover {
            color: var(--accent-hover);
        }
        .apply-accent-ring:focus {
            --tw-ring-color: var(--accent-main);
        }
        .apply-accent-bg-light {
            background-color: var(--accent-bg-light);
        }
        .apply-progress-track {
            background-color: var(--progress-track);
        }

        /* Styles for range input thumbs to use dynamic/static accent variables */
        .dynamic-thumb::-webkit-slider-thumb {
            background-color: var(--accent-main);
            box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.4);
        }
        .dynamic-thumb::-moz-range-thumb {
            background-color: var(--accent-main);
            box-shadow: 0 0 0 4px rgba(var(--accent-rgb), 0.4);
        }
        .dynamic-thumb::-webkit-slider-thumb:hover {
            background-color: var(--accent-hover);
            box-shadow: 0 0 0 6px rgba(var(--accent-rgb), 0.6);
        }
        .dynamic-thumb::-moz-range-thumb:hover {
            background-color: var(--accent-hover);
            box-shadow: 0 0 0 6px rgba(var(--accent-rgb), 0.6);
        }

        /* Custom Context Menu Styles */
        #custom-context-menu, #playlist-context-menu {
            position: absolute;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 150px;
            overflow: hidden;
            padding: 0.25rem 0;
        }

        #custom-context-menu ul, #playlist-context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #custom-context-menu li, #playlist-context-menu li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            color: var(--text-primary);
            transition: background-color 0.15s ease-in-out;
            display: flex;
            align-items: center;
        }

        #custom-context-menu li i, #playlist-context-menu li i {
            margin-right: 0.75rem;
            color: var(--text-secondary);
        }

        #custom-context-menu li:hover, #playlist-context-menu li:hover {
            background-color: var(--bg-secondary);
        }

        /* Now Playing Animation Styles */
        .now-playing-animation {
            display: inline-flex; /* Use inline-flex to keep it next to text */
            align-items: flex-end; /* Align bars to the bottom */
            height: 16px; /* Adjust height as needed */
            width: 16px; /* Adjust width as needed */
            margin-right: 8px; /* Space *before* text */
            vertical-align: middle; /* Align vertically with text */
            overflow: hidden; /* Hide overflow from animation */
        }

        .now-playing-animation .bar {
            width: 4px; /* Width of each bar */
            height: 4px; /* Initial height */
            background-color: var(--accent-main); /* Match accent color */
            margin: 0 1px; /* Space between bars */
            animation: bounce 0.6s ease-in-out infinite alternate;
        }

        .now-playing-animation .bar:nth-child(2) {
            animation-delay: 0.15s; /* Stagger animation */
        }

        .now-playing-animation .bar:nth-child(3) {
            animation-delay: 0.3s; /* Stagger animation */
        }

        @keyframes bounce {
            0% {
                transform: scaleY(0.3); /* Start small */
                height: 4px;
            }
            100% {
                transform: scaleY(1); /* Grow to full height */
                height: 16px;
            }
        }

        /* Ensure line breaks are respected in LLM response area */
        #llm-response-area {
            white-space: pre-wrap; /* Preserves whitespace and wraps lines */
            text-align: left; /* Align text to the left for readability */
            padding: 1rem; /* Add padding for better readability inside the scrollable area */
            overflow-y: auto; /* Make it scrollable */
            flex-grow: 1; /* Allow it to take up available space */
            min-height: 100px; /* Give it a minimum height */
            /* Removed max-height: 100%; to allow flex-grow to manage height */
            height: 0; /* Important for flex items with overflow to work correctly */
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--border-color);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            max-width: 90%;
            max-height: 90%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-800 to-purple-900 min-h-screen flex items-center justify-center p-4 dark-mode-gradient">

    <div class="player-container rounded-xl shadow-2xl p-8 max-w-lg w-full flex flex-col h-full transform transition-all duration-300 scale-100 hover:scale-105">
        <!-- Removed H1 for "MP3 Player" text -->

        <!-- Tab Content Areas -->
        <div id="now-playing-tab-content" class="tab-content active-tab flex flex-col h-full">
            <!-- Album Art / Placeholder -->
            <div class="bg-gray-200 w-48 h-48 mx-auto rounded-lg shadow-inner flex items-center justify-center mb-4">
                <img id="album-art" src="https://placehold.co/192x192/9333ea/ffffff?text=Album+Art" alt="Album Art" class="rounded-lg w-full h-full object-cover">
            </div>

            <!-- Song Info -->
            <div class="text-center mb-3">
                <h2 id="song-title" class="text-2xl font-bold truncate mb-1 text-primary">Song Title</h2>
                <p id="song-artist" class="text-lg text-secondary truncate">Artist Name</p>
            </div>

            <!-- Progress Bar -->
            <div class="mb-4 relative">
                <input type="range" id="progress-bar" value="0" min="0" max="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer apply-progress-track dynamic-thumb">
                <div class="text-sm text-secondary mt-1 relative w-full h-5">
                    <span id="current-time" class="absolute top-0 -translate-x-1/2">0:00</span>
                    <span id="duration" class="absolute top-0 right-0">0:00</span>
                </div>
            </div>

            <!-- Player Controls -->
            <div class="flex justify-center items-center space-x-6 mb-4">
                <button id="shuffle-btn" class="text-secondary hover:apply-accent-text transition-colors duration-200 focus:outline-none focus:apply-accent-ring p-2 rounded-full">
                    <i class="fas fa-random text-xl"></i>
                </button>
                <button id="prev-btn" class="text-secondary hover:apply-accent-text transition-colors duration-200 focus:outline-none focus:apply-accent-ring p-2 rounded-full">
                    <i class="fas fa-backward text-3xl"></i>
                </button>
                <button id="play-pause-btn" class="apply-accent-color text-white p-4 rounded-full shadow-lg hover:apply-accent-hover transform hover:scale-105 transition-all duration-200 ease-in-out focus:outline-none focus:apply-accent-ring focus:ring-opacity-75">
                    <i id="play-pause-icon" class="fas fa-play text-3xl"></i>
                </button>
                <button id="next-btn" class="text-secondary hover:apply-accent-text transition-colors duration-200 focus:outline-none focus:apply-accent-ring p-2 rounded-full">
                    <i class="fas fa-forward text-3xl"></i>
                </button>
                <button id="repeat-btn" class="text-secondary hover:apply-accent-text transition-colors duration-200 focus:outline-none focus:apply-accent-ring p-2 rounded-full">
                    <i id="repeat-icon" class="fas fa-redo-alt text-xl"></i>
                </button>
            </div>

            <!-- Volume Control -->
            <div class="flex items-center justify-center space-x-3 mb-4">
                <i class="fas fa-volume-down text-secondary"></i>
                <input type="range" id="volume-bar" value="100" min="0" max="100" class="w-1/2 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer dynamic-thumb">
                <i class="fas fa-volume-up text-secondary"></i>
            </div>

            <!-- Gemini AI Features Button -->
            <div class="relative flex justify-center space-x-4 mb-4 z-10">
                <button id="ai-features-toggle-btn" class="apply-accent-color hover:apply-accent-hover text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:-translate-y-1 hover:shadow-lg focus:outline-none focus:ring-2 focus:apply-accent-ring focus:ring-opacity-50">
                    <i class="fas fa-magic mr-2"></i>AI Features <i class="fas fa-chevron-down ml-2"></i>
                </button>
                <div id="ai-features-dropdown-menu" class="absolute top-full mt-2 w-48 bg-white dark:bg-gray-700 rounded-lg shadow-xl hidden overflow-hidden border border-border-color">
                    <ul class="py-1">
                        <li>
                            <button id="get-song-info-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">
                                ✨ Get Song Info
                            </button>
                        </li>
                        <li>
                            <button id="get-artist-bio-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">
                                ✨ Get Artist Bio
                            </button>
                        </li>
                        <li>
                            <button id="generate-song-story-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">
                                ✨ Generate Song Story
                            </button>
                        </li>
                        <li>
                            <button id="suggest-similar-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">
                                ✨ Suggest Similar Vibes
                            </button>
                        </li>
                        <li>
                            <button id="explain-lyrics-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">
                                ✨ Explain Lyrics
                            </button>
                        </li>
                        <li>
                            <button id="song-trivia-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">
                                ✨ Song Trivia
                            </button>
                        </li>
                        <li>
                            <button id="create-playlist-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600">
                                ✨ Create Playlist
                            </button>
                        </li>
                    </ul>
                </div>
            </div>


            <!-- LLM Response Display Area (scrollable and text-aligned left) -->
            <div id="llm-response-area" class="border border-border-color rounded-lg p-4 bg-secondary mt-4 flex-grow overflow-y-auto text-secondary italic">
                AI-generated insights will appear here.
            </div>
            <div id="loading-indicator" class="text-center apply-accent-text mt-2 hidden">
                <i class="fas fa-spinner fa-spin mr-2"></i>Loading...
            </div>
        </div>

        <div id="library-tab-content" class="tab-content hidden">
            <h3 class="text-xl font-semibold text-center mb-4 apply-accent-text">Your Library</h3>
            <div class="mb-4 text-center">
                <input type="file" id="add-files-input" accept="audio/*" multiple class="hidden">
                <button id="add-files-btn" class="apply-accent-color hover:apply-accent-hover text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    <i class="fas fa-plus mr-2"></i>Add Local Files
                </button>
                <p class="text-sm text-secondary mt-2">
                    Select audio files from your device. For security, direct folder access is not allowed.
                </p>
            </div>
            <!-- Search Box for Library -->
            <div class="mb-4">
                <input type="text" id="library-search-input" placeholder="Search songs by title or artist..." class="w-full p-2 rounded-lg border border-border-color bg-secondary text-primary focus:outline-none focus:ring-2 focus:apply-accent-ring">
            </div>
            <ul id="playlist-items" class="space-y-3 max-h-64 overflow-y-auto pr-2 border border-border-color rounded-lg p-2 bg-secondary">
                <!-- Playlist items will be injected here by JavaScript -->
                <li class="p-3 text-secondary text-center">No songs in library. Add some!</li>
            </ul>
        </div>

        <!-- New Playlists Tab Content -->
        <div id="playlists-tab-content" class="tab-content hidden flex-col h-full">
            <!-- Main Playlists List View -->
            <div id="playlists-main-view" class="flex flex-col h-full">
                <h3 class="text-xl font-semibold text-center mb-4 apply-accent-text">Your Playlists</h3>
                <div class="mb-4 text-center">
                    <button id="create-new-playlist-btn" class="apply-accent-color hover:apply-accent-hover text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                        <i class="fas fa-plus mr-2"></i>Create New Playlist
                    </button>
                </div>
                <ul id="playlists-list" class="space-y-3 max-h-64 overflow-y-auto pr-2 border border-border-color rounded-lg p-2 bg-secondary">
                    <li class="p-3 text-secondary text-center italic">No playlists created yet.</li>
                </ul>
            </div>

            <!-- Playlist Detail View (Initially Hidden) -->
            <div id="playlist-detail-view" class="hidden flex flex-col h-full">
                <div class="flex items-center mb-4">
                    <button id="back-to-playlists-btn" class="text-secondary hover:apply-accent-text transition-colors duration-200 p-2 rounded-full">
                        <i class="fas fa-arrow-left text-xl"></i>
                    </button>
                    <h3 id="playlist-detail-name" class="text-2xl font-bold text-center flex-grow apply-accent-text truncate">Playlist Name</h3>
                </div>

                <div class="flex justify-center items-center space-x-4 mb-4">
                    <button id="play-playlist-btn" class="apply-accent-color hover:apply-accent-hover text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                        <i class="fas fa-play mr-2"></i>Play All
                    </button>
                    <button id="shuffle-playlist-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                        <i class="fas fa-random mr-2"></i>Shuffle All
                    </button>
                    <button id="edit-playlist-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                        <i class="fas fa-edit mr-2"></i>Edit
                    </button>
                </div>

                <ul id="playlist-detail-songs" class="space-y-3 flex-grow overflow-y-auto pr-2 border border-border-color rounded-lg p-2 bg-secondary">
                    <!-- Songs in this playlist will be injected here -->
                    <li class="p-3 text-secondary text-center italic">No songs in this playlist.</li>
                </ul>
            </div>
        </div>


        <div id="settings-tab-content" class="tab-content hidden">
            <h3 class="text-xl font-semibold text-center mb-4 apply-accent-text">Settings</h3>

            <!-- Theme / Dark Mode Toggle -->
            <div class="flex items-center justify-between mb-6 p-4 border border-border-color rounded-lg bg-secondary">
                <span class="text-primary font-medium">Dark Mode</span>
                <label for="dark-mode-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="dark-mode-toggle" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                </label>
            </div>

            <!-- Dynamic Album Art Accent Toggle -->
            <div class="flex items-center justify-between mb-6 p-4 border border-border-color rounded-lg bg-secondary">
                <span class="text-primary font-medium">Dynamic Album Art Accent</span>
                <label for="dynamic-accent-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="dynamic-accent-toggle" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                </label>
            </div>

            <!-- Accent Color Selection -->
            <div id="static-accent-options" class="mb-6 p-4 border border-border-color rounded-lg bg-secondary">
                <h4 class="text-primary font-medium mb-3">Accent Color (Static)</h4>
                <div class="flex justify-around space-x-2">
                    <button class="w-10 h-10 rounded-full bg-purple-500 hover:ring-2 ring-offset-2 ring-purple-500 transition-all duration-200" data-accent-color="purple" title="Purple Theme"></button>
                    <button class="w-10 h-10 rounded-full bg-blue-500 hover:ring-2 ring-offset-2 ring-blue-500 transition-all duration-200" data-accent-color="blue" title="Blue Theme"></button>
                    <button class="w-10 h-10 rounded-full bg-green-500 hover:ring-2 ring-offset-2 ring-green-500 transition-all duration-200" data-accent-color="green" title="Green Theme"></button>
                    <button class="w-10 h-10 rounded-full bg-red-500 hover:ring-2 ring-offset-2 ring-red-500 transition-all duration-200" data-accent-color="red" title="Red Theme"></button>
                </div>
            </div>

            <!-- Playback Speed Control -->
            <div class="mb-6 p-4 border border-border-color rounded-lg bg-secondary">
                <h4 class="text-primary font-medium mb-3">Playback Speed</h4>
                <div class="flex items-center space-x-3">
                    <span id="playback-speed-value" class="text-primary font-semibold w-10 text-right">1.0x</span>
                    <input type="range" id="playback-speed-bar" value="10" min="5" max="20" step="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer dynamic-thumb">
                </div>
                <p class="text-sm text-secondary mt-2">Adjust song playback speed (0.5x to 2.0x).</p>
            </div>

            <!-- Future Settings (placeholder) -->
            <div class="p-4 border border-border-color rounded-lg bg-secondary text-secondary text-center italic">
                More settings coming soon!
            </div>
        </div>


        <!-- Tabs Navigation -->
        <div class="flex justify-around mt-8 border-t border-border-color pt-4">
            <button id="tab-now-playing" class="tab-button active-tab flex-1 py-3 px-2 rounded-lg transition-colors duration-200 flex flex-col items-center mx-1">
                <i class="fas fa-play-circle text-xl mb-1"></i>
                <span class="text-xs font-medium">Now Playing</span>
            </button>
            <button id="tab-library" class="tab-button flex-1 py-3 px-2 rounded-lg transition-colors duration-200 flex flex-col items-center mx-1">
                <i class="fas fa-music text-xl mb-1"></i>
                <span class="text-xs font-medium">Library</span>
            </button>
            <button id="tab-playlists" class="tab-button flex-1 py-3 px-2 rounded-lg transition-colors duration-200 flex flex-col items-center mx-1">
                <i class="fas fa-list-music text-xl mb-1"></i>
                <span class="text-xs font-medium">Playlists</span>
            </button>
            <button id="tab-settings" class="tab-button flex-1 py-3 px-2 rounded-lg transition-colors duration-200 flex flex-col items-center mx-1">
                <i class="fas fa-cog text-xl mb-1"></i>
                <span class="text-xs font-medium">Settings</span>
            </button>
        </div>
    </div>

    <!-- Hidden Audio Element -->
    <audio id="audio-player" class="hidden"></audio>

    <!-- Hidden Canvas for color extraction -->
    <canvas id="color-canvas" class="hidden"></canvas>

    <!-- Custom Context Menu for Songs -->
    <div id="custom-context-menu" class="hidden">
        <ul>
            <li data-action="playNext"><i class="fas fa-step-forward"></i>Play Next</li>
            <li data-action="addToQueue"><i class="fas fa-list-ul"></i>Add to Queue</li>
            <li data-action="delete"><i class="fas fa-trash-alt"></i>Delete from Library</li>
            <hr class="border-t border-border-color my-1">
            <li data-action="getSongInfo"><i class="fas fa-info-circle"></i>Get Song Info (AI)</li>
            <li data-action="getArtistBio"><i class="fas fa-user-circle"></i>Get Artist Bio (AI)</li>
        </ul>
    </div>

    <!-- Custom Context Menu for Playlists -->
    <div id="playlist-context-menu" class="hidden">
        <ul>
            <li data-action="play-playlist"><i class="fas fa-play"></i>Play</li>
            <li data-action="shuffle-playlist"><i class="fas fa-random"></i>Shuffle</li>
            <li data-action="edit-playlist"><i class="fas fa-edit"></i>Edit</li>
            <hr class="border-t border-border-color my-1">
            <li data-action="delete-playlist"><i class="fas fa-trash-alt"></i>Delete Playlist</li>
        </ul>
    </div>

    <!-- Playlist Creation Modal -->
    <div id="create-playlist-modal" class="modal-overlay hidden">
        <div class="modal-content w-full md:w-3/4 lg:w-1/2 xl:w-2/5 h-3/4">
            <h3 class="text-2xl font-semibold text-center mb-4 apply-accent-text">Create New Playlist</h3>

            <div class="mb-4">
                <label for="playlist-name-input" class="block text-primary text-sm font-medium mb-2">Playlist Name:</label>
                <input type="text" id="playlist-name-input" placeholder="Enter playlist name" class="w-full p-2 rounded-lg border border-border-color bg-secondary text-primary focus:outline-none focus:ring-2 focus:apply-accent-ring">
            </div>

            <div class="mb-4">
                <label for="create-playlist-search-input" class="block text-primary text-sm font-medium mb-2">Search Songs:</label>
                <input type="text" id="create-playlist-search-input" placeholder="Search songs to add..." class="w-full p-2 rounded-lg border border-border-color bg-secondary text-primary focus:outline-none focus:ring-2 focus:apply-accent-ring">
            </div>

            <div class="flex-grow overflow-y-auto pr-2 mb-4 border border-border-color rounded-lg p-2 bg-secondary">
                <ul id="create-playlist-songs" class="space-y-2">
                    <!-- Songs with checkboxes will be loaded here -->
                    <li class="p-3 text-secondary text-center italic">No songs in library. Add some!</li>
                </ul>
            </div>

            <div class="flex justify-end space-x-4 mt-auto">
                <button id="cancel-create-playlist-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Cancel
                </button>
                <button id="save-playlist-btn" class="apply-accent-color hover:apply-accent-hover text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out">
                    Save Playlist
                </button>
            </div>
        </div>
    </div>

    <script>
        // Initial playlist is empty, user must add their own music
        let playlist = []; // This is the currently active playing queue
        let playlists = []; // Array to store created playlists (metadata only)

        let originalPlaylistOrder = []; // This is the full library of all added songs
        let nextSongId = 1; // For assigning unique IDs to new songs, starts at 1
        let currentEditingPlaylistId = null; // To track which playlist is being edited

        // Get references to DOM elements
        const audioPlayer = document.getElementById('audio-player');
        const songTitleEl = document.getElementById('song-title');
        const songArtistEl = document.getElementById('song-artist');
        const albumArtEl = document.getElementById('album-art');
        // The crossOrigin attribute should be set here, before any src is assigned to albumArtEl
        albumArtEl.crossOrigin = 'anonymous';

        const progressBar = document.getElementById('progress-bar');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const playPauseIcon = document.getElementById('play-pause-icon');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const repeatBtn = document.getElementById('repeat-btn');
        const repeatIcon = document.getElementById('repeat-icon');
        const volumeBar = document.getElementById('volume-bar');
        const playlistItemsEl = document.getElementById('playlist-items'); // Library list

        // AI Features specific elements
        const aiFeaturesToggleBtn = document.getElementById('ai-features-toggle-btn');
        const aiFeaturesDropdownMenu = document.getElementById('ai-features-dropdown-menu');
        const getSongInfoBtn = document.getElementById('get-song-info-btn');
        const getArtistBioBtn = document.getElementById('get-artist-bio-btn');
        const generateSongStoryBtn = document.getElementById('generate-song-story-btn');
        const suggestSimilarBtn = document.getElementById('suggest-similar-btn');
        const explainLyricsBtn = document.getElementById('explain-lyrics-btn');
        const songTriviaBtn = document.getElementById('song-trivia-btn');
        const createPlaylistAiBtn = document.getElementById('create-playlist-btn');

        const llmResponseArea = document.getElementById('llm-response-area');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Tab related elements
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const tabNowPlayingBtn = document.getElementById('tab-now-playing');
        const tabLibraryBtn = document.getElementById('tab-library');
        const tabPlaylistsBtn = document.getElementById('tab-playlists');
        const tabSettingsBtn = document.getElementById('tab-settings');
        const nowPlayingTabContent = document.getElementById('now-playing-tab-content');
        const libraryTabContent = document.getElementById('library-tab-content');
        const playlistsTabContent = document.getElementById('playlists-tab-content');
        const settingsTabContent = document.getElementById('settings-tab-content');

        // Library Tab elements
        const addFilesBtn = document.getElementById('add-files-btn');
        const addFilesInput = document.getElementById('add-files-input');
        const librarySearchInput = document.getElementById('library-search-input');

        // Playlists Tab elements
        const playlistsMainView = document.getElementById('playlists-main-view');
        const createNewPlaylistBtn = document.getElementById('create-new-playlist-btn');
        const playlistsListEl = document.getElementById('playlists-list');

        // Playlist Detail View elements
        const playlistDetailView = document.getElementById('playlist-detail-view');
        const backToPlaylistsBtn = document.getElementById('back-to-playlists-btn');
        const playlistDetailName = document.getElementById('playlist-detail-name');
        const playPlaylistBtn = document.getElementById('play-playlist-btn');
        const shufflePlaylistBtn = document.getElementById('shuffle-playlist-btn');
        const editPlaylistBtn = document.getElementById('edit-playlist-btn');
        const playlistDetailSongsEl = document.getElementById('playlist-detail-songs');

        // Playlist Creation Modal elements
        const createPlaylistModal = document.getElementById('create-playlist-modal');
        const playlistNameInput = document.getElementById('playlist-name-input');
        const createPlaylistSearchInput = document.getElementById('create-playlist-search-input');
        const createPlaylistSongsEl = document.getElementById('create-playlist-songs');
        const savePlaylistBtn = document.getElementById('save-playlist-btn');
        const cancelCreatePlaylistBtn = document.getElementById('cancel-create-playlist-btn');

        // Settings Tab elements
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const dynamicAccentToggle = document.getElementById('dynamic-accent-toggle');
        const staticAccentOptions = document.getElementById('static-accent-options');
        const accentColorButtons = document.querySelectorAll('#static-accent-options [data-accent-color]');
        const body = document.body;
        const playerContainer = document.querySelector('.player-container');
        // Playback speed elements
        const playbackSpeedBar = document.getElementById('playback-speed-bar');
        const playbackSpeedValue = document.getElementById('playback-speed-value');

        // Canvas for color extraction
        const colorCanvas = document.getElementById('color-canvas');
        const colorCtx = colorCanvas.getContext('2d');

        // Context Menu elements
        const customContextMenu = document.getElementById('custom-context-menu'); // For songs
        const playlistContextMenu = document.getElementById('playlist-context-menu'); // For playlists
        let rightClickedSongId = null;
        let rightClickedPlaylistId = null; // To store the ID of the playlist right-clicked

        let currentSongIndex = 0;
        let isPlaying = false;
        let isShuffling = false;
        let repeatMode = 0;

        /**
         * Converts RGB to HSL.
         * Used for color manipulation to derive light/dark variants.
         * @param {number} r - Red component (0-255).
         * @param {number} g - Green component (0-255).
         * @param {number} b - Blue component (0-255).
         * @returns {number[]} HSL array [h, s, l].
         */
        function rgbToHsl(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }

        /**
         * Converts HSL to RGB.
         * Used for color manipulation to derive light/dark variants.
         * @param {number} h - Hue (0-360).
         * @param {number} s - Saturation (0-100).
         * @param {number} l - Lightness (0-100).
         * @returns {number[]} RGB array [r, g, b].
         */
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            let r, g, b;

            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        /**
         * Extracts a dominant color from an image URL by loading it into a temporary Image object
         * and drawing it to a canvas. This handles cross-origin loading correctly.
         * @param {string} imageUrl - The URL of the image to sample (can be data:URL).
         * @returns {Promise<string|null>} A promise that resolves to an RGB string "R,G,B" or null if extraction fails.
         */
        function getDominantColor(imageUrl) {
            return new Promise(resolve => {
                // Do not attempt to get color from placeholder images
                if (!imageUrl || imageUrl.startsWith('https://placehold.co')) {
                    console.log("Skipping color extraction for placeholder image.");
                    return resolve(null);
                }

                const tempImg = new Image();
                tempImg.crossOrigin = 'anonymous'; // Essential for local images/data URIs to prevent tainting
                tempImg.src = imageUrl;

                tempImg.onload = () => {
                    if (!tempImg.naturalWidth || !tempImg.naturalHeight) {
                        console.warn("Temporary image loaded but has zero dimensions, cannot extract color.");
                        return resolve(null);
                    }
                    colorCanvas.width = tempImg.naturalWidth;
                    colorCanvas.height = tempImg.naturalHeight;
                    try {
                        colorCtx.drawImage(tempImg, 0, 0);
                        // Sample a single pixel from the center
                        const pixel = colorCtx.getImageData(tempImg.naturalWidth / 2, tempImg.naturalHeight / 2, 1, 1).data;
                        const r = pixel[0];
                        const g = pixel[1];
                        const b = pixel[2];
                        resolve(`${r},${g},${b}`);
                    } catch (e) {
                        console.error("Error drawing image to canvas or getting pixel data (likely security/CORS issue):", e);
                        resolve(null);
                    }
                };
                tempImg.onerror = (e) => {
                    console.error("Error loading temporary image for color extraction:", e);
                    resolve(null);
                };
            });
        }

        /**
         * Applies the dynamic accent colors based on a given RGB color.
         * @param {string} rgbString - The RGB color string (e.g., "100,150,200").
         */
        function applyDynamicAccent(rgbString) {
            const root = document.documentElement;
            const isDarkMode = body.classList.contains('dark-mode');

            // First, ensure all default static accent classes are removed from the player container and body
            playerContainer.classList.remove('accent-purple', 'accent-blue', 'accent-green', 'accent-red');
            body.classList.remove('accent-purple', 'accent-blue', 'accent-green', 'accent-red');

            if (!rgbString) {
                console.warn("No valid RGB string provided for dynamic accent, falling back to static.");
                const savedAccentColor = localStorage.getItem('mp3PlayerAccentColor') || 'purple';
                applyStaticAccent(savedAccentColor); // Fallback
                return;
            }

            let [r, g, b] = rgbString.split(',').map(Number);
            let [h, s, l] = rgbToHsl(r, g, b);

            let accentMainRgb, accentHoverRgb, accentBgLightRgb, progressTrackRgb;

            if (isDarkMode) {
                // Adjust lightness for dark mode to ensure visibility and contrast
                // Clamp lightness between 30 and 85, and shift it up.
                const adjustedL = Math.min(85, Math.max(30, l + 30));
                accentMainRgb = hslToRgb(h, s, adjustedL);
                accentHoverRgb = hslToRgb(h, s, Math.max(0, adjustedL - 15)); // Darken from new main
                accentBgLightRgb = hslToRgb(h, s, Math.min(100, adjustedL + 15)); // Lighten from new main (less intense light background for dark mode)
                progressTrackRgb = hslToRgb(h, s, Math.min(100, adjustedL + 10)); // Slightly lighter for track
            } else {
                // Original light mode logic
                accentMainRgb = [r, g, b];
                accentHoverRgb = hslToRgb(h, s, Math.max(0, l - 15));
                accentBgLightRgb = hslToRgb(h, s, Math.min(100, l + 50));
                progressTrackRgb = hslToRgb(h, s, Math.min(100, l + 30));
            }

            // Set CSS custom properties directly on the root element
            root.style.setProperty('--accent-main', `rgb(${accentMainRgb.join(',')})`);
            root.style.setProperty('--accent-hover', `rgb(${accentHoverRgb.join(',')})`);
            root.style.setProperty('--accent-bg-light', `rgb(${accentBgLightRgb.join(',')})`);
            root.style.setProperty('--accent-rgb', `${accentMainRgb.join(',')}`); // For box-shadow rgba
            root.style.setProperty('--progress-track', `rgb(${progressTrackRgb.join(',')})`);

            // Visually disable static color buttons when dynamic is active
            staticAccentOptions.classList.add('opacity-50', 'pointer-events-none');
            accentColorButtons.forEach(btn => btn.disabled = true);
        }

        /**
         * Applies one of the predefined static accent colors.
         * @param {string} colorName - The name of the predefined color (e.g., 'purple').
         */
        function applyStaticAccent(colorName) {
            const root = document.documentElement;

            // Clear any previously set dynamic properties
            root.style.removeProperty('--accent-main');
            root.style.removeProperty('--accent-hover');
            root.style.removeProperty('--accent-bg-light');
            root.style.removeProperty('--accent-rgb');
            root.style.removeProperty('--progress-track');

            // Remove all specific accent classes first
            playerContainer.classList.remove('accent-purple', 'accent-blue', 'accent-green', 'accent-red');
            body.classList.remove('accent-purple', 'accent-blue', 'accent-green', 'accent-red');

            // Add the selected static accent class
            playerContainer.classList.add(`accent-${colorName}`);
            body.classList.add(`accent-${colorName}`); // Apply to body for global thumb styles

            // Re-enable static color buttons
            staticAccentOptions.classList.remove('opacity-50', 'pointer-events-none');
            accentColorButtons.forEach(btn => btn.disabled = false);
        }

        /**
         * Formats time from seconds to MM:SS string.
         * @param {number} seconds - The time in seconds.
         * @returns {string} Formatted time string (MM:SS).
         */
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "0:00";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        /**
         * Loads and displays the details of the current song.
         * Sets the audio player's source.
         * @param {boolean} [shouldPlayImmediately=false] - Whether to start playing immediately after loading.
         */
        async function loadSong(shouldPlayImmediately = false) {
            const song = playlist[currentSongIndex];
            if (!song) {
                // Handle empty playlist case
                songTitleEl.textContent = "No Song Loaded";
                songArtistEl.textContent = "Add songs to your library!";
                albumArtEl.src = "https://placehold.co/192x192/cccccc/333333?text=No+Music";
                progressBar.value = 0;
                currentTimeEl.textContent = "0:00";
                durationEl.textContent = "0:00";
                pauseSong(); // Ensure player is paused
                await updateAccentColors(); // Update theme even if no song
                return;
            }

            songTitleEl.textContent = song.title;
            songArtistEl.textContent = song.artist;
            const newAlbumArtSrc = song.albumArt || "https://placehold.co/192x192/cccccc/333333?text=No+Art";

            // Always update album art source for display
            albumArtEl.src = newAlbumArtSrc;

            // Trigger accent color update after updating album art source
            // The updateAccentColors function will use getDominantColor which
            // itself handles the image loading for color extraction.
            await updateAccentColors();

            audioPlayer.src = song.src;

            // Wait for metadata to load to get actual duration
            audioPlayer.onloadedmetadata = () => {
                durationEl.textContent = formatTime(audioPlayer.duration);
                progressBar.max = audioPlayer.duration;
                // Fallback to playlist duration if actual audio duration is not ready or invalid
                if (isNaN(audioPlayer.duration) || !isFinite(audioPlayer.duration)) {
                    progressBar.max = song.duration || 0; // Use song's defined duration as fallback
                }
            };

            audioPlayer.currentTime = 0; // Reset playback to start
            currentTimeEl.textContent = formatTime(0); // Reset current time display
            progressBar.value = 0; // Reset progress bar

            if (shouldPlayImmediately) {
                playSong();
            }

            updatePlaylistUI();
        }

        /**
         * Plays the current song.
         */
        function playSong() {
            if (audioPlayer.paused) { // Only play if currently paused
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        isPlaying = true;
                        playPauseIcon.classList.remove('fa-play');
                        playPauseIcon.classList.add('fa-pause');
                        updatePlaylistUI(); // Update UI for "Now Playing" animation
                    }).catch(error => {
                        console.error("Error playing audio:", error);
                        llmResponseArea.textContent = "Error playing song. Please check the console for details and ensure audio files are accessible and compatible (e.g., MP3).";
                        pauseSong(); // Ensure UI is consistent if play fails
                    });
                }
            }
        }

        /**
         * Pauses the current song.
         */
        function pauseSong() {
            if (!audioPlayer.paused) { // Only pause if currently playing
                audioPlayer.pause();
                isPlaying = false;
                playPauseIcon.classList.remove('fa-pause');
                playPauseIcon.classList.add('fa-play');
                updatePlaylistUI(); // Update UI for "Now Playing" animation
            }
        }

        /**
         * Toggles between play and pause.
         */
        function togglePlayPause() {
            if (playlist.length === 0) {
                llmResponseArea.textContent = "Please add songs to your library first!";
                llmResponseArea.classList.add('text-center'); // Re-center for generic messages
                return;
            }
            if (isPlaying) {
                pauseSong();
            } else {
                playSong();
            }
        }

        /**
         * Plays the next song in the playlist based on shuffle/repeat mode.
         */
        function nextSong() {
            if (playlist.length === 0) return;

            if (repeatMode === 2) { // Repeat one
                loadSong(true); // Re-load and play current song
            } else if (isShuffling) {
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * playlist.length);
                } while (newIndex === currentSongIndex && playlist.length > 1); // Ensure different song if more than one
                currentSongIndex = newIndex;
                loadSong(true);
            } else { // No shuffle or repeat all
                currentSongIndex++;
                if (currentSongIndex >= playlist.length) {
                    if (repeatMode === 1) { // Repeat all
                        currentSongIndex = 0; // Loop back to the start
                    } else { // No repeat, stop playback
                        currentSongIndex = 0; // Reset to first song
                        loadSong(); // Load first song without playing
                        pauseSong(); // Ensure it's paused
                        return;
                    }
                }
                loadSong(true);
            }
        }

        /**
         * Plays the previous song in the playlist.
         */
        function prevSong() {
            if (playlist.length === 0) return;

            if (repeatMode === 2) { // Repeat one
                loadSong(true); // Re-load and play current song
            } else {
                currentSongIndex--;
                if (currentSongIndex < 0) {
                    currentSongIndex = playlist.length - 1; // Loop to end
                }
                loadSong(true);
            }
        }

        /**
         * Handles direct seeking on the progress bar.
         */
        function seek() {
            audioPlayer.currentTime = progressBar.value;
        }

        /**
         * Toggles shuffle mode.
         */
        function toggleShuffle() {
            isShuffling = !isShuffling;
            shuffleBtn.classList.toggle('apply-accent-text', isShuffling);
            shuffleBtn.classList.toggle('font-bold', isShuffling);

            if (isShuffling) {
                // Ensure there's a current song to keep at index 0 if shuffling
                if (playlist.length > 0) {
                    const currentSong = playlist[currentSongIndex];
                    const remainingSongs = playlist.filter((_, index) => index !== currentSongIndex);

                    // Fisher-Yates (Knuth) shuffle algorithm for remaining songs
                    for (let i = remainingSongs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [remainingSongs[i], remainingSongs[j]] = [remainingSongs[j], remainingSongs[i]];
                    }

                    // Reconstruct playlist with current song at the beginning
                    playlist = [currentSong, ...remainingSongs];
                    currentSongIndex = 0; // Current song is now at index 0
                }
            } else {
                // Restore original playlist order
                const currentSongId = playlist[currentSongIndex]?.id; // Use optional chaining
                playlist = [...originalPlaylistOrder]; // Use spread to create new array
                if (currentSongId !== undefined) {
                    currentSongIndex = playlist.findIndex(song => song.id === currentSongId); // Find index of current song in original order
                    if (currentSongIndex === -1) currentSongIndex = 0; // Fallback if current song somehow not found
                } else {
                    currentSongIndex = 0; // Reset if no song was playing
                }
            }
            renderPlaylist(); // Re-render playlist to reflect order
        }

        /**
         * Toggles repeat mode: 0 (no repeat) -> 1 (repeat all) -> 2 (repeat one) -> 0.
         */
        function toggleRepeat() {
            repeatMode = (repeatMode + 1) % 3; // Cycle through 0, 1, 2
            // Remove all active classes first for clean toggling
            repeatIcon.classList.remove('fa-redo', 'fa-redo-alt', 'fa-repeat-1');
            repeatBtn.classList.remove('apply-accent-text', 'font-bold');

            switch (repeatMode) {
                case 0: // No repeat
                    repeatIcon.classList.add('fa-redo-alt'); // Default icon
                    break;
                case 1: // Repeat all
                    repeatIcon.classList.add('fa-redo', 'apply-accent-text', 'font-bold');
                    break;
                case 2: // Repeat one
                    // Use fa-repeat-1 if available, otherwise fa-redo-alt with a visual indication in Font Awesome 6.x
                    // For simplicity and broader compatibility, we'll just use fa-redo-alt and color for 'repeat one' state
                    repeatIcon.classList.add('fa-redo-alt', 'apply-accent-text', 'font-bold');
                    // If you have Font Awesome Pro or newer versions that include fa-repeat-1-alt or fa-repeat-1, you could use that.
                    break;
            }
        }

        /**
         * Sets the volume of the audio player.
         */
        function setVolume() {
            audioPlayer.volume = volumeBar.value / 100;
        }

        /**
         * Renders a list of songs into a specified UL element.
         * This function is now generic for library and playlist detail views.
         * @param {Array} songsToRender - The array of song objects to display.
         * @param {HTMLElement} targetUl - The UL element to render the songs into.
         */
        function renderSongsList(songsToRender, targetUl) {
            targetUl.innerHTML = ''; // Clear existing list

            if (songsToRender.length === 0) {
                targetUl.innerHTML = '<li class="p-3 text-secondary text-center italic">No songs found.</li>';
                return;
            }

            songsToRender.forEach((song) => {
                const li = document.createElement('li');
                li.className = `p-3 rounded-lg cursor-pointer flex items-center space-x-3 transition-colors duration-200 ${
                    // Highlight currently playing song visually
                    (song.id === playlist[currentSongIndex]?.id && isPlaying) ? 'apply-accent-bg-light apply-accent-text font-semibold shadow-md' : 'bg-secondary hover:bg-gray-200 text-secondary'
                }`;
                li.setAttribute('data-song-id', song.id); // Store song ID on the element

                // Album Art for song list items
                const albumArtImg = document.createElement('img');
                albumArtImg.src = song.albumArt || "https://placehold.co/40x40/cccccc/333333?text=Art";
                albumArtImg.alt = "Album Art";
                albumArtImg.className = "w-10 h-10 rounded-md object-cover flex-shrink-0";
                li.appendChild(albumArtImg);

                const songInfoContainer = document.createElement('div');
                songInfoContainer.className = "flex flex-col flex-1 min-w-0 pr-2";

                // Title line with animation
                const titleLineFlex = document.createElement('div');
                titleLineFlex.className = "flex items-center text-sm font-medium";
                if (song.id === playlist[currentSongIndex]?.id && isPlaying) {
                    const animationDiv = document.createElement('div');
                    animationDiv.className = "now-playing-animation flex-shrink-0";
                    animationDiv.innerHTML = `<span class="bar"></span><span class="bar"></span><span class="bar"></span>`;
                    titleLineFlex.appendChild(animationDiv);
                }
                const titleSpan = document.createElement('span');
                titleSpan.className = "truncate";
                titleSpan.textContent = song.title;
                titleLineFlex.appendChild(titleSpan);

                // Artist line
                const artistSpan = document.createElement('span');
                artistSpan.className = "text-xs text-secondary mt-1 truncate";
                artistSpan.textContent = song.artist;

                songInfoContainer.appendChild(titleLineFlex);
                songInfoContainer.appendChild(artistSpan);
                li.appendChild(songInfoContainer);

                // Duration
                const durationDiv = document.createElement('div');
                durationDiv.className = "text-xs text-secondary flex-shrink-0";
                durationDiv.textContent = formatTime(song.duration);
                li.appendChild(durationDiv);

                li.addEventListener('click', () => {
                    // When clicking a song in any list, find its index in the global `originalPlaylistOrder`
                    // and then update the `playlist` and `currentSongIndex` to reflect playing this song.
                    const actualSongInLibrary = originalPlaylistOrder.find(s => s.id === song.id);
                    if (actualSongInLibrary) {
                        // If the clicked song is from the library/a playlist, set the main 'playlist'
                        // to the current context (either filtered library or the specific playlist songs)
                        // and then play the song.
                        // For simplicity, when playing from a list, we'll make that list the current `playlist`.
                        playlist = songsToRender; // Set the current playing queue to the displayed list
                        currentSongIndex = playlist.findIndex(s => s.id === song.id);
                        loadSong(true);
                    } else if (isPlaying && song.id === playlist[currentSongIndex]?.id) {
                        pauseSong();
                    } else {
                        // This case should ideally not be hit if `actualSongInLibrary` is found
                        // or if the song is already playing.
                        console.warn("Clicked song not found in library or already playing:", song);
                    }
                });
                li.addEventListener('contextmenu', (e) => showContextMenu(e, song.id));
                targetUl.appendChild(li);
            });
        }


        /**
         * Updates the UI to highlight the currently playing song in the playlist.
         * This function is now also responsible for showing/hiding the animation.
         */
        function updatePlaylistUI() {
            // Re-render the library view
            filterAndRenderLibrary();
            // Re-render the playlist detail view if it's active
            if (!playlistDetailView.classList.contains('hidden')) {
                const currentPlaylist = playlists.find(p => p.id === playlistDetailView.dataset.playlistId);
                if (currentPlaylist) {
                    renderSongsList(currentPlaylist.songs, playlistDetailSongsEl);
                }
            }
        }

        /**
         * Handles the selection of local audio files.
         * Extracts metadata using jsmediatags.
         * @param {Event} event - The change event from the file input.
         */
        async function handleFiles(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            llmResponseArea.textContent = "Adding songs to your library...";
            loadingIndicator.classList.remove('hidden');

            const newSongs = [];
            for (const file of files) {
                if (file.type.startsWith('audio/')) {
                    const audioUrl = URL.createObjectURL(file);
                    let title = file.name.replace(/\.(mp3|wav|ogg|aac|flac)$/i, ''); // Added more common audio extensions
                    let artist = "Unknown Artist";
                    let albumArt = "https://placehold.co/192x192/cccccc/333333?text=No+Art";
                    let duration = 0;

                    // Read ID3 tags using jsmediatags
                    await new Promise(resolve => {
                        jsmediatags.read(file, {
                            onSuccess: function(tag) {
                                if (tag.tags.title) title = tag.tags.title;
                                if (tag.tags.artist) artist = tag.tags.artist;
                                if (tag.tags.picture) {
                                    const picture = tag.tags.picture;
                                    let base64String = "";
                                    for (let i = 0; i < picture.data.length; i++) {
                                        base64String += String.fromCharCode(picture.data[i]);
                                    }
                                    albumArt = `data:${picture.format};base64,${btoa(base64String)}`;
                                }
                                resolve();
                            },
                            onError: function(error) {
                                console.warn(`Error reading ID3 tags for ${file.name}:`, error.type, error.info);
                                resolve(); // Resolve anyway to proceed with file
                            }
                        });
                    });

                    // Get audio duration using a temporary Audio object
                    try {
                        const tempAudio = new Audio(audioUrl);
                        await new Promise(resolve => {
                            tempAudio.onloadedmetadata = () => {
                                duration = tempAudio.duration;
                                resolve();
                            };
                            tempAudio.onerror = () => {
                                console.error("Error loading metadata for file duration:", file.name);
                                resolve();
                            };
                            // In case metadata doesn't load quickly, add a timeout
                            setTimeout(resolve, 3000); // Max 3 seconds to get duration
                        });
                    } catch (e) {
                        console.error("Error creating temp audio for duration:", e);
                    }

                    newSongs.push({
                        id: nextSongId++,
                        title: title,
                        artist: artist,
                        duration: duration || 180, // Default to 3 minutes if duration can't be read
                        src: audioUrl,
                        albumArt: albumArt
                    });
                }
            }

            // Add new songs to the playlist and original order
            originalPlaylistOrder.push(...newSongs); // Add to the master library list
            
            // If the current playing playlist is empty, or this is the first song added,
            // set the main playlist to the originalPlaylistOrder and load the first song.
            if (playlist.length === 0 && originalPlaylistOrder.length > 0) {
                playlist = [...originalPlaylistOrder]; // Set current playing queue to full library
                currentSongIndex = 0;
                loadSong();
            }

            filterAndRenderLibrary(); // Re-render with potential search filter
            loadingIndicator.classList.add('hidden');
            llmResponseArea.textContent = `${newSongs.length} song(s) added to your library!`;
            llmResponseArea.classList.add('text-center'); // Re-center this message
        }

        /**
         * Filters the library based on the search input and re-renders the playlist.
         */
        function filterAndRenderLibrary() {
            const searchTerm = librarySearchInput.value.toLowerCase();
            let filteredSongs = originalPlaylistOrder; // Always filter from the original, full list

            if (searchTerm) {
                filteredSongs = originalPlaylistOrder.filter(song =>
                    song.title.toLowerCase().includes(searchTerm) ||
                    song.artist.toLowerCase().includes(searchTerm)
                );
            }
            renderSongsList(filteredSongs, playlistItemsEl); // Pass the filtered list and target UL
        }

        /**
         * Calls the Gemini API to get information based on the prompt.
         * @param {string} promptText - The text prompt for the LLM.
         * @param {Object} [songContext=null] - Optional song object to provide context for LLM queries.
         * @param {Object} [responseSchema=null] - Optional schema for structured JSON responses.
         */
        async function getGeminiResponse(promptText, songContext = null, responseSchema = null) {
            let actualPrompt = promptText;
            if (songContext) {
                actualPrompt = actualPrompt.replace('${song.title}', songContext.title || 'a song')
                                           .replace('${song.artist}', songContext.artist || 'an artist');
            }

            if (playlist.length === 0 && !songContext && !responseSchema) { // Only block if no song and not a general query like playlist creation
                llmResponseArea.textContent = "Please add songs to your library first!";
                llmResponseArea.classList.add('text-center');
                return;
            }


            loadingIndicator.classList.remove('hidden'); // Show loading indicator
            llmResponseArea.textContent = ''; // Clear previous response
            llmResponseArea.classList.remove('text-center'); // Ensure left alignment for responses

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: actualPrompt }] });
                
                const payload = { contents: chatHistory };
                const headers = { 'Content-Type': 'application/json' };

                if (responseSchema) {
                    payload.generationConfig = {
                        responseMimeType: "application/json",
                        responseSchema: responseSchema
                    };
                }

                const apiKey = ""; // Your Gemini API Key is inserted here
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    
                    if (responseSchema) {
                        try {
                            const parsedJson = JSON.parse(text);
                            // Format for display for playlist
                            if (Array.isArray(parsedJson) && parsedJson.every(item => item.title && item.artist)) {
                                let formattedPlaylist = "Here's a suggested playlist:\n\n";
                                parsedJson.forEach((item, index) => {
                                    formattedPlaylist += `${index + 1}. ${item.title} by ${item.artist}\n`;
                                });
                                llmResponseArea.textContent = formattedPlaylist;
                            } else {
                                llmResponseArea.textContent = "AI generated an unexpected structured response. Please try a different prompt.";
                                console.warn("Unexpected structured response:", parsedJson);
                            }
                        } catch (parseError) {
                            llmResponseArea.textContent = "AI generated malformed JSON. Please try again.";
                            console.error("Error parsing AI JSON response:", parseError, text);
                        }
                    } else {
                        llmResponseArea.textContent = text;
                    }

                } else {
                    llmResponseArea.textContent = "Could not get a response from the AI. Please try again.";
                    llmResponseArea.classList.add('text-center');
                    console.error("Unexpected Gemini API response structure:", result);
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                llmResponseArea.textContent = "An error occurred while fetching AI response. Please try again later.";
                llmResponseArea.classList.add('text-center');
            } finally {
                loadingIndicator.classList.add('hidden'); // Hide loading indicator
            }
        }

        /**
         * Handles tab switching.
         * @param {string} tabId - The ID of the tab content to show.
         * @param {HTMLElement} clickedButton - The button that was clicked.
         */
        function switchTab(tabId, clickedButton) {
            // Hide all tab contents
            tabContents.forEach(content => content.classList.add('hidden'));
            // Remove active class from all buttons
            tabButtons.forEach(button => button.classList.remove('active-tab', 'apply-accent-color', 'text-white'));

            // Show the selected tab content
            document.getElementById(tabId).classList.remove('hidden');
            // Add active class to the clicked button
            clickedButton.classList.add('active-tab', 'apply-accent-color', 'text-white');

            // Specific actions for each tab
            if (tabId === 'library-tab-content') {
                filterAndRenderLibrary();
            } else if (tabId === 'playlists-tab-content') {
                playlistsMainView.classList.remove('hidden');
                playlistDetailView.classList.add('hidden'); // Ensure detail view is hidden
                renderPlaylists();
            }
        }

        /**
         * Applies the accent color theme based on the dynamic toggle.
         * This is the master function for applying accent colors.
         */
        async function updateAccentColors() {
            if (dynamicAccentToggle.checked) {
                // Pass the albumArtEl.src directly to the asynchronous getDominantColor function
                const dominantColor = await getDominantColor(albumArtEl.src);
                applyDynamicAccent(dominantColor);
            } else {
                const savedAccentColor = localStorage.getItem('mp3PlayerAccentColor') || 'purple';
                applyStaticAccent(savedAccentColor);
            }
            // Re-render playlist to ensure colors are applied to individual items (e.g., active song highlight)
            updatePlaylistUI(); // Use the unified UI update function
        }


        /**
         * Initializes the theme based on local storage or default.
         */
        function initializeTheme() {
            // Dark Mode
            const savedDarkMode = localStorage.getItem('mp3PlayerDarkMode');
            if (savedDarkMode === 'true') {
                body.classList.add('dark-mode');
                darkModeToggle.checked = true;
            } else {
                body.classList.remove('dark-mode');
                darkModeToggle.checked = false;
            }

            // Dynamic Accent Toggle
            const savedDynamicAccent = localStorage.getItem('mp3PlayerDynamicAccent');
            if (savedDynamicAccent === 'true') {
                dynamicAccentToggle.checked = true;
            } else {
                dynamicAccentToggle.checked = false; // Default to off
            }

            // Load saved playlists
            const savedPlaylists = localStorage.getItem('mp3PlayerPlaylists');
            if (savedPlaylists) {
                playlists = JSON.parse(savedPlaylists);
            }
            // Load saved library (originalPlaylistOrder)
            const savedLibrary = localStorage.getItem('mp3PlayerLibrary');
            if (savedLibrary) {
                originalPlaylistOrder = JSON.parse(savedLibrary);
                // Re-create object URLs for local files upon load
                originalPlaylistOrder.forEach(song => {
                    if (song.file) { // Assuming 'file' property exists for original File object
                        // This part is tricky. File objects cannot be directly stored or re-created from path.
                        // For persistent local file playback, you'd need a more advanced API like File System Access API
                        // or have the user re-select files on each load.
                        // For now, we'll just keep the src as is, knowing it might break on refresh if not a data URI.
                        // Data URIs (for album art) are fine.
                    }
                });
            }


            // Apply colors based on initial dynamic accent state (which will then call applyStaticAccent or applyDynamicAccent)
            updateAccentColors(); // This is called initially, and then by loadSong after album art changes

            // Set initial active tab button color
            tabNowPlayingBtn.classList.add('apply-accent-color', 'text-white');
        }

        /**
         * Displays the custom context menu at the given coordinates.
         * @param {MouseEvent} e - The mouse event.
         * @param {number} songId - The ID of the song that was right-clicked.
         */
        function showContextMenu(e, songId) {
            e.preventDefault(); // Prevent default browser context menu

            rightClickedSongId = songId; // Store the ID of the song clicked

            // Position the menu
            customContextMenu.style.left = `${e.clientX}px`;
            customContextMenu.style.top = `${e.clientY}px`;
            customContextMenu.classList.remove('hidden');

            // Adjust position if it goes off screen
            const menuWidth = customContextMenu.offsetWidth;
            const menuHeight = customContextMenu.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (e.clientX + menuWidth > viewportWidth) {
                customContextMenu.style.left = `${viewportWidth - menuWidth - 10}px`; // 10px padding
            }
            if (e.clientY + menuHeight > viewportHeight) {
                customContextMenu.style.top = `${viewportHeight - menuHeight - 10}px`; // 10px padding
            }
        }

        /**
         * Hides the custom context menu.
         */
        function hideContextMenu() {
            customContextMenu.classList.add('hidden');
            rightClickedSongId = null; // Clear the stored song ID
        }

        /**
         * Displays the playlist context menu at the given coordinates.
         * @param {MouseEvent} e - The mouse event.
         * @param {number} playlistId - The ID of the playlist that was right-clicked.
         */
        function showPlaylistContextMenu(e, playlistId) {
            e.preventDefault(); // Prevent default browser context menu

            rightClickedPlaylistId = playlistId; // Store the ID of the playlist clicked

            // Position the menu
            playlistContextMenu.style.left = `${e.clientX}px`;
            playlistContextMenu.style.top = `${e.clientY}px`;
            playlistContextMenu.classList.remove('hidden');

            // Adjust position if it goes off screen
            const menuWidth = playlistContextMenu.offsetWidth;
            const menuHeight = playlistContextMenu.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (e.clientX + menuWidth > viewportWidth) {
                playlistContextMenu.style.left = `${viewportWidth - menuWidth - 10}px`; // 10px padding
            }
            if (e.clientY + menuHeight > viewportHeight) {
                playlistContextMenu.style.top = `${viewportHeight - menuHeight - 10}px`; // 10px padding
            }
        }

        /**
         * Hides the playlist context menu.
         */
        function hidePlaylistContextMenu() {
            playlistContextMenu.classList.add('hidden');
            rightClickedPlaylistId = null; // Clear the stored playlist ID
        }


        /**
         * Handles actions triggered by the custom context menu (for songs).
         * @param {Event} e - The click event.
         */
        function handleContextMenuAction(e) {
            hideContextMenu(); // Hide menu immediately

            const action = e.target.closest('li')?.dataset.action;
            if (!action || rightClickedSongId === null) return;

            const clickedSongIndex = playlist.findIndex(song => song.id === rightClickedSongId);
            const clickedSong = playlist[clickedSongIndex]; // This is the song in the *current playing queue*

            // Find the song in the *master library* to ensure we're deleting the correct one
            const songInLibraryIndex = originalPlaylistOrder.findIndex(s => s.id === rightClickedSongId);
            const songInLibrary = originalPlaylistOrder[songInLibraryIndex];

            if (!clickedSong && !songInLibrary) return; // Should not happen if rightClickedSongId is valid

            switch (action) {
                case 'playNext':
                    if (playlist.length === 0) {
                        llmResponseArea.textContent = "Playlist is empty. Add songs first.";
                        return;
                    }
                    // If the song is already in the playing queue, remove it from its current spot
                    if (clickedSongIndex !== -1) {
                        playlist.splice(clickedSongIndex, 1);
                        // Adjust currentSongIndex if the removed song was before it
                        if (clickedSongIndex < currentSongIndex) {
                            currentSongIndex--;
                        }
                    }

                    // Add the song right after the current playing song
                    const songToAdd = songInLibrary || clickedSong; // Prefer library version if available
                    if (songToAdd) {
                        let insertIndex = currentSongIndex + 1;
                        if (insertIndex > playlist.length) { // If current song is last or playlist is empty
                            insertIndex = playlist.length;
                        }
                        playlist.splice(insertIndex, 0, songToAdd);
                        llmResponseArea.textContent = `"${songToAdd.title}" will play next!`;
                    } else {
                        llmResponseArea.textContent = "Could not find song to play next.";
                    }
                    updatePlaylistUI();
                    break;
                case 'addToQueue':
                    if (playlist.length === 0) {
                        llmResponseArea.textContent = "Playlist is empty. Add songs first.";
                        return;
                    }
                    const songToAddToQueue = songInLibrary || clickedSong;
                    if (songToAddToQueue) {
                        playlist.push(songToAddToQueue);
                        llmResponseArea.textContent = `"${songToAddToQueue.title}" added to queue!`;
                    } else {
                        llmResponseArea.textContent = "Could not find song to add to queue.";
                    }
                    updatePlaylistUI();
                    break;
                case 'delete':
                    if (confirm(`Are you sure you want to delete "${songInLibrary.title}" from your library? This will remove it from all playlists.`)) {
                        // Remove from originalPlaylistOrder (master library)
                        originalPlaylistOrder = originalPlaylistOrder.filter(s => s.id !== rightClickedSongId);
                        localStorage.setItem('mp3PlayerLibrary', JSON.stringify(originalPlaylistOrder));

                        // Remove from all saved playlists
                        playlists.forEach(p => {
                            p.songs = p.songs.filter(s => s.id !== rightClickedSongId);
                        });
                        localStorage.setItem('mp3PlayerPlaylists', JSON.stringify(playlists));

                        // If the deleted song was in the current playing queue (playlist)
                        if (clickedSongIndex !== -1) {
                            const wasPlaying = (currentSongIndex === clickedSongIndex);
                            const wasLastSongInQueue = (playlist.length === 1);

                            playlist.splice(clickedSongIndex, 1); // Remove from current playing queue

                            if (wasPlaying) {
                                if (wasLastSongInQueue) {
                                    currentSongIndex = 0; // Reset index for empty playlist state
                                    loadSong(); // Load empty state
                                    pauseSong(); // Ensure player is stopped
                                } else {
                                    if (currentSongIndex >= playlist.length) {
                                        currentSongIndex = 0;
                                    }
                                    loadSong(true);
                                }
                            } else if (clickedSongIndex < currentSongIndex) {
                                currentSongIndex--;
                            }
                        }
                        llmResponseArea.textContent = `"${songInLibrary.title}" deleted from library and all playlists.`;
                        updatePlaylistUI(); // Re-render all relevant lists
                        renderPlaylists(); // Re-render playlist list to reflect song counts
                    }
                    break;
                case 'getSongInfo':
                    const songInfoPrompt = `Provide a short, interesting fact or brief analysis (2-3 sentences) about the song "${songInLibrary.title}" by "${songInLibrary.artist}". If you don't know, provide a generic but positive statement about music.`;
                    getGeminiResponse(songInfoPrompt, songInLibrary);
                    switchTab('now-playing-tab-content', tabNowPlayingBtn);
                    break;
                case 'getArtistBio':
                    const artistBioPrompt = `Provide a very short bio (2-3 sentences) or a fun fact about the artist "${songInLibrary.artist}". If you don't know, provide a generic but positive statement about musical artists.`;
                    getGeminiResponse(artistBioPrompt, songInLibrary);
                    switchTab('now-playing-tab-content', tabNowPlayingBtn);
                    break;
            }
        }

        /**
         * Handles actions triggered by the playlist context menu.
         * @param {Event} e - The click event.
         */
        function handlePlaylistContextMenuAction(e) {
            hidePlaylistContextMenu(); // Hide menu immediately

            const action = e.target.closest('li')?.dataset.action;
            if (!action || rightClickedPlaylistId === null) return;

            const clickedPlaylist = playlists.find(p => p.id === rightClickedPlaylistId);
            if (!clickedPlaylist) return;

            switch (action) {
                case 'play-playlist':
                    playlist = [...clickedPlaylist.songs]; // Set current playing queue to this playlist's songs
                    currentSongIndex = 0;
                    loadSong(true);
                    llmResponseArea.textContent = `Playing playlist: "${clickedPlaylist.name}"`;
                    llmResponseArea.classList.add('text-center');
                    switchTab('now-playing-tab-content', tabNowPlayingBtn);
                    break;
                case 'shuffle-playlist':
                    playlist = [...clickedPlaylist.songs]; // Set current playing queue
                    isShuffling = true; // Enable shuffle
                    shuffleBtn.classList.add('apply-accent-text', 'font-bold'); // Visually indicate shuffle is on
                    // Shuffle the current playlist
                    for (let i = playlist.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
                    }
                    currentSongIndex = 0; // Start from the first shuffled song
                    loadSong(true);
                    llmResponseArea.textContent = `Shuffling and playing playlist: "${clickedPlaylist.name}"`;
                    llmResponseArea.classList.add('text-center');
                    switchTab('now-playing-tab-content', tabNowPlayingBtn);
                    break;
                case 'edit-playlist':
                    showCreatePlaylistModal(clickedPlaylist.id);
                    break;
                case 'delete-playlist':
                    if (confirm(`Are you sure you want to delete playlist "${clickedPlaylist.name}"? This cannot be undone.`)) {
                        playlists = playlists.filter(p => p.id !== rightClickedPlaylistId);
                        localStorage.setItem('mp3PlayerPlaylists', JSON.stringify(playlists));
                        llmResponseArea.textContent = `Playlist "${clickedPlaylist.name}" deleted.`;
                        llmResponseArea.classList.add('text-center');
                        renderPlaylists(); // Re-render the main playlist list
                    }
                    break;
            }
        }


        // Event Listeners for Audio Element
        audioPlayer.addEventListener('timeupdate', () => {
            if (!isNaN(audioPlayer.duration) && isFinite(audioPlayer.duration)) {
                progressBar.value = audioPlayer.currentTime;
                
                const progressPercentage = audioPlayer.currentTime / audioPlayer.duration;
                
                // Position current-time relative to the progress bar width
                // The -translate-x-1/2 class on currentTimeEl will center it on this calculated left position
                currentTimeEl.style.left = `${progressPercentage * 100}%`;
                currentTimeEl.textContent = formatTime(audioPlayer.currentTime);

                // Hide duration if current time is near the end
                // Adjust the threshold (e.g., 0.85 means hide if progress is beyond 85%)
                const HIDE_DURATION_THRESHOLD = 0.85;
                if (progressPercentage > HIDE_DURATION_THRESHOLD && audioPlayer.duration > 0) {
                    durationEl.classList.add('hidden');
                } else {
                    durationEl.classList.remove('hidden');
                }
            }
        });

        audioPlayer.addEventListener('ended', () => {
            nextSong(); // Play next song when current one ends
        });

        audioPlayer.addEventListener('error', (e) => {
            console.error("Audio element error:", e);
            llmResponseArea.textContent = "Error playing audio. The file might be corrupted or inaccessible.";
            pauseSong();
        });


        // Event Listeners for Player Controls
        playPauseBtn.addEventListener('click', togglePlayPause);
        prevBtn.addEventListener('click', prevSong);
        nextBtn.addEventListener('click', nextSong);
        progressBar.addEventListener('input', seek);
        shuffleBtn.addEventListener('click', toggleShuffle);
        repeatBtn.addEventListener('click', toggleRepeat);
        volumeBar.addEventListener('input', setVolume);

        // Event Listeners for Gemini AI Buttons
        getSongInfoBtn.addEventListener('click', () => {
            const currentSong = playlist[currentSongIndex];
            if (!currentSong) {
                llmResponseArea.textContent = "No song is loaded to get information about.";
                llmResponseArea.classList.add('text-center'); // Re-center for generic messages
                return;
            }
            const prompt = `Provide a short, interesting fact or brief analysis (2-3 sentences) about the song "${currentSong.title}" by "${currentSong.artist}". If you don't know, provide a generic but positive statement about music.`;
            getGeminiResponse(prompt, currentSong);
            aiFeaturesDropdownMenu.classList.add('hidden'); // Hide dropdown after selection
        });

        getArtistBioBtn.addEventListener('click', () => {
            const currentSong = playlist[currentSongIndex];
            if (!currentSong) {
                llmResponseArea.textContent = "No song is loaded to get artist information about.";
                llmResponseArea.classList.add('text-center'); // Re-center for generic messages
                return;
            }
            const prompt = `Provide a very short bio (2-3 sentences) or a fun fact about the artist "${currentSong.artist}". If you don't know, provide a generic but positive statement about musical artists.`;
            getGeminiResponse(prompt, currentSong);
            aiFeaturesDropdownMenu.classList.add('hidden'); // Hide dropdown after selection
        });

        generateSongStoryBtn.addEventListener('click', () => {
            const currentSong = playlist[currentSongIndex];
            if (!currentSong) {
                llmResponseArea.textContent = "Please play a song to generate a story!";
                llmResponseArea.classList.add('text-center'); // Re-center for generic messages
                return;
            }
            const prompt = `Write a very short, imaginative story (3-5 sentences) inspired by the song title "${currentSong.title}" and artist "${currentSong.artist}". Focus on mood and imagery related to the title.`;
            getGeminiResponse(prompt, currentSong);
            aiFeaturesDropdownMenu.classList.add('hidden'); // Hide dropdown after selection
        });

        suggestSimilarBtn.addEventListener('click', () => {
            const currentSong = playlist[currentSongIndex];
            if (!currentSong) {
                llmResponseArea.textContent = "Please play a song to get similar music suggestions!";
                llmResponseArea.classList.add('text-center'); // Re-center for generic messages
                return;
            }
            const prompt = `Suggest 3-5 song titles or artists that are musically similar in style or mood to "${currentSong.title}" by "${currentSong.artist}". If you can't provide specific examples, suggest common genres or moods that listeners of this type of music might enjoy.`;
            getGeminiResponse(prompt, currentSong);
            aiFeaturesDropdownMenu.classList.add('hidden'); // Hide dropdown after selection
        });

        // New AI Feature Listeners
        explainLyricsBtn.addEventListener('click', () => {
            const currentSong = playlist[currentSongIndex];
            if (!currentSong) {
                llmResponseArea.textContent = "No song is loaded to explain lyrics for.";
                llmResponseArea.classList.add('text-center');
                return;
            }
            // For actual lyric explanation, you'd need the lyrics.
            // Since we don't extract lyrics, we'll ask for a creative interpretation.
            const prompt = `Provide a brief, creative interpretation of possible themes or meanings behind a song titled "${currentSong.title}" by "${currentSong.artist}". If the song title is generic, interpret it generally. If you have no information, say so.`;
            getGeminiResponse(prompt, currentSong);
            aiFeaturesDropdownMenu.classList.add('hidden');
        });

        songTriviaBtn.addEventListener('click', () => {
            const currentSong = playlist[currentSongIndex];
            if (!currentSong) {
                llmResponseArea.textContent = "No song is loaded to generate trivia for.";
                llmResponseArea.classList.add('text-center');
                return;
            }
            const prompt = `Generate one short trivia question (with answer) about the song "${currentSong.title}" by "${currentSong.artist}", or if no specific information is available, a general music trivia question. Format: "Question: ... Answer: ..."`;
            getGeminiResponse(prompt, currentSong);
            aiFeaturesDropdownMenu.classList.add('hidden');
        });

        createPlaylistAiBtn.addEventListener('click', () => {
            const moodOrActivity = prompt("Enter a mood or activity for your playlist (e.g., 'workout', 'relaxing', 'study'):");
            if (moodOrActivity) {
                const playlistPrompt = `Generate a short playlist of 5 songs for a ${moodOrActivity} mood/activity. Provide only the song titles and artists in a JSON array format. Example: [{"title": "Song A", "artist": "Artist X"}, {"title": "Song B", "artist": "Artist Y"}]`;
                const playlistSchema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "title": { "type": "STRING" },
                            "artist": { "type": "STRING" }
                        },
                        required: ["title", "artist"]
                    },
                    "propertyOrdering": ["title", "artist"]
                };
                getGeminiResponse(playlistPrompt, null, playlistSchema);
                aiFeaturesDropdownMenu.classList.add('hidden');
            }
        });


        // Event Listeners for Tabs
        tabNowPlayingBtn.addEventListener('click', () => switchTab('now-playing-tab-content', tabNowPlayingBtn));
        tabLibraryBtn.addEventListener('click', () => switchTab('library-tab-content', tabLibraryBtn));
        tabPlaylistsBtn.addEventListener('click', () => switchTab('playlists-tab-content', tabPlaylistsBtn));
        tabSettingsBtn.addEventListener('click', () => switchTab('settings-tab-content', tabSettingsBtn));

        // Event Listeners for Library Tab
        addFilesBtn.addEventListener('click', () => addFilesInput.click()); // Trigger hidden input click
        addFilesInput.addEventListener('change', handleFiles);
        librarySearchInput.addEventListener('input', filterAndRenderLibrary); // New: Listen for input to filter

        // Event Listeners for Playlists Tab
        createNewPlaylistBtn.addEventListener('click', () => {
            showCreatePlaylistModal();
        });

        /**
         * Renders the list of created playlists.
         */
        function renderPlaylists() {
            playlistsListEl.innerHTML = ''; // Clear existing list

            if (playlists.length === 0) {
                playlistsListEl.innerHTML = '<li class="p-3 text-secondary text-center italic">No playlists created yet.</li>';
                return;
            }

            playlists.forEach(p => {
                const li = document.createElement('li');
                li.className = 'p-3 rounded-lg bg-secondary hover:bg-gray-200 text-primary cursor-pointer transition-colors duration-200 flex justify-between items-center';
                li.setAttribute('data-playlist-id', p.id); // Store playlist ID on the element
                li.innerHTML = `
                    <div>
                        <div class="font-semibold">${p.name}</div>
                        <div class="text-sm text-secondary">${p.songs.length} songs</div>
                    </div>
                    <button class="text-secondary hover:apply-accent-text p-1 rounded-full text-lg" data-action="play-playlist-direct" data-playlist-id="${p.id}">
                        <i class="fas fa-play-circle"></i>
                    </button>
                `;
                // Add event listener to show playlist detail view
                li.addEventListener('click', () => showPlaylistDetail(p.id));
                // Add right-click listener for playlist context menu
                li.addEventListener('contextmenu', (e) => showPlaylistContextMenu(e, p.id));
                // Add direct play button listener (for the play icon on the list item)
                li.querySelector('[data-action="play-playlist-direct"]').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent li click from opening detail
                    playSelectedPlaylist(p.id);
                });
                playlistsListEl.appendChild(li);
            });
        }

        /**
         * Shows the playlist detail view for a specific playlist.
         * @param {number} playlistId - The ID of the playlist to display.
         */
        function showPlaylistDetail(playlistId) {
            const selectedPlaylist = playlists.find(p => p.id === playlistId);
            if (!selectedPlaylist) {
                llmResponseArea.textContent = "Playlist not found.";
                llmResponseArea.classList.add('text-center');
                return;
            }

            playlistsMainView.classList.add('hidden');
            playlistDetailView.classList.remove('hidden');
            playlistDetailView.dataset.playlistId = playlistId; // Store current playlist ID

            playlistDetailName.textContent = selectedPlaylist.name;
            renderSongsList(selectedPlaylist.songs, playlistDetailSongsEl); // Render songs in detail view
        }

        /**
         * Goes back from the playlist detail view to the main playlists list.
         */
        function backToPlaylists() {
            playlistDetailView.classList.add('hidden');
            playlistsMainView.classList.remove('hidden');
            renderPlaylists(); // Re-render the main list
        }

        /**
         * Plays the selected playlist.
         * @param {number} playlistId - The ID of the playlist to play.
         */
        function playSelectedPlaylist(playlistId) {
            const selectedPlaylist = playlists.find(p => p.id === playlistId);
            if (selectedPlaylist && selectedPlaylist.songs.length > 0) {
                playlist = [...selectedPlaylist.songs]; // Set the main playing queue
                currentSongIndex = 0;
                isShuffling = false; // Turn off shuffle if playing directly
                shuffleBtn.classList.remove('apply-accent-text', 'font-bold');
                loadSong(true);
                llmResponseArea.textContent = `Playing playlist: "${selectedPlaylist.name}"`;
                llmResponseArea.classList.add('text-center');
                switchTab('now-playing-tab-content', tabNowPlayingBtn);
            } else {
                llmResponseArea.textContent = "This playlist is empty or not found.";
                llmResponseArea.classList.add('text-center');
            }
        }

        /**
         * Shuffles and plays the selected playlist.
         * @param {number} playlistId - The ID of the playlist to shuffle and play.
         */
        function shuffleSelectedPlaylist(playlistId) {
            const selectedPlaylist = playlists.find(p => p.id === playlistId);
            if (selectedPlaylist && selectedPlaylist.songs.length > 0) {
                playlist = [...selectedPlaylist.songs]; // Set the main playing queue
                isShuffling = true; // Enable shuffle
                shuffleBtn.classList.add('apply-accent-text', 'font-bold');
                // Shuffle the current playlist
                for (let i = playlist.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
                }
                currentSongIndex = 0; // Start from the first shuffled song
                loadSong(true);
                llmResponseArea.textContent = `Shuffling and playing playlist: "${selectedPlaylist.name}"`;
                llmResponseArea.classList.add('text-center');
                switchTab('now-playing-tab-content', tabNowPlayingBtn);
            } else {
                llmResponseArea.textContent = "This playlist is empty or not found.";
                llmResponseArea.classList.add('text-center');
            }
        }


        // Playlist Creation Modal Functions
        /**
         * Shows the playlist creation/edit modal.
         * @param {number|null} [editPlaylistId=null] - The ID of the playlist to edit, or null for new.
         */
        function showCreatePlaylistModal(editPlaylistId = null) {
            createPlaylistModal.classList.remove('hidden');
            playlistNameInput.value = ''; // Clear previous name
            createPlaylistSearchInput.value = ''; // Clear previous search
            currentEditingPlaylistId = editPlaylistId;

            let preSelectedSongIds = [];
            if (editPlaylistId !== null) {
                const playlistToEdit = playlists.find(p => p.id === editPlaylistId);
                if (playlistToEdit) {
                    playlistNameInput.value = playlistToEdit.name;
                    preSelectedSongIds = playlistToEdit.songs.map(s => s.id);
                }
            }

            renderSongsForPlaylistCreation(originalPlaylistOrder, preSelectedSongIds); // Show all songs initially
        }

        function hideCreatePlaylistModal() {
            createPlaylistModal.classList.add('hidden');
            currentEditingPlaylistId = null; // Clear editing state
        }

        /**
         * Renders songs for the playlist creation modal with checkboxes.
         * @param {Array} songsToRender - The array of songs to display.
         * @param {Array} preSelectedSongIds - Array of song IDs that should be pre-checked.
         */
        function renderSongsForPlaylistCreation(songsToRender, preSelectedSongIds = []) {
            createPlaylistSongsEl.innerHTML = ''; // Clear existing list

            if (songsToRender.length === 0) {
                createPlaylistSongsEl.innerHTML = '<li class="p-3 text-secondary text-center italic">No songs found in your library.</li>';
                return;
            }

            songsToRender.forEach(song => {
                const li = document.createElement('li');
                li.className = 'p-2 rounded-lg bg-secondary hover:bg-gray-200 text-primary flex items-center space-x-3 transition-colors duration-200';
                const isChecked = preSelectedSongIds.includes(song.id) ? 'checked' : '';
                li.innerHTML = `
                    <input type="checkbox" id="modal-song-checkbox-${song.id}" data-song-id="${song.id}" class="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500 apply-accent-text" ${isChecked}>
                    <label for="modal-song-checkbox-${song.id}" class="flex-1 cursor-pointer flex items-center space-x-2">
                        <img src="${song.albumArt || "https://placehold.co/30x30/cccccc/333333?text=Art"}" alt="Album Art" class="w-8 h-8 rounded-sm object-cover">
                        <div>
                            <div class="font-medium truncate">${song.title}</div>
                            <div class="text-sm text-secondary truncate">${song.artist}</div>
                        </div>
                    </label>
                `;
                createPlaylistSongsEl.appendChild(li);
            });
        }

        /**
         * Filters songs in the playlist creation modal based on search input.
         */
        function filterSongsForPlaylistCreation() {
            const searchTerm = createPlaylistSearchInput.value.toLowerCase();
            const filteredSongs = originalPlaylistOrder.filter(song =>
                song.title.toLowerCase().includes(searchTerm) ||
                song.artist.toLowerCase().includes(searchTerm)
            );
            // Re-render with existing checked state if editing
            const preSelectedSongIds = Array.from(createPlaylistSongsEl.querySelectorAll('input[type="checkbox"]:checked'))
                                           .map(checkbox => parseInt(checkbox.dataset.songId));
            renderSongsForPlaylistCreation(filteredSongs, preSelectedSongIds);
        }

        /**
         * Saves the new or edited playlist.
         */
        function saveNewPlaylist() {
            const playlistName = playlistNameInput.value.trim();
            if (!playlistName) {
                llmResponseArea.textContent = "Please enter a name for your playlist.";
                llmResponseArea.classList.add('text-center');
                return;
            }

            const selectedSongIds = Array.from(createPlaylistSongsEl.querySelectorAll('input[type="checkbox"]:checked'))
                                       .map(checkbox => parseInt(checkbox.dataset.songId));

            if (selectedSongIds.length === 0) {
                llmResponseArea.textContent = "Please select at least one song for your playlist.";
                llmResponseArea.classList.add('text-center');
                return;
            }

            // Ensure selected songs are full objects from originalPlaylistOrder
            const selectedSongs = originalPlaylistOrder.filter(song => selectedSongIds.includes(song.id));

            if (currentEditingPlaylistId !== null) {
                // Editing existing playlist
                const existingPlaylistIndex = playlists.findIndex(p => p.id === currentEditingPlaylistId);
                if (existingPlaylistIndex !== -1) {
                    playlists[existingPlaylistIndex].name = playlistName;
                    
                    // Filter out existing songs from selectedSongs to avoid duplicates
                    const existingSongIds = new Set(playlists[existingPlaylistIndex].songs.map(s => s.id));
                    const uniqueNewSongs = selectedSongs.filter(song => !existingSongIds.has(song.id));

                    // Combine existing songs with unique new songs
                    playlists[existingPlaylistIndex].songs = [...playlists[existingPlaylistIndex].songs, ...uniqueNewSongs];

                    llmResponseArea.textContent = `Playlist "${playlistName}" updated! Added ${uniqueNewSongs.length} new song(s).`;
                }
            } else {
                // Creating new playlist
                const newPlaylist = {
                    id: Date.now(), // Simple unique ID
                    name: playlistName,
                    songs: selectedSongs
                };
                playlists.push(newPlaylist);
                llmResponseArea.textContent = `Playlist "${playlistName}" created with ${selectedSongs.length} songs!`;
            }

            localStorage.setItem('mp3PlayerPlaylists', JSON.stringify(playlists)); // Save to local storage

            llmResponseArea.classList.add('text-center');
            hideCreatePlaylistModal();
            renderPlaylists(); // Update the playlists list on the main tab
            switchTab('playlists-tab-content', tabPlaylistsBtn); // Switch to Playlists tab
        }


        // Event Listeners for Settings Tab
        darkModeToggle.addEventListener('change', () => {
            body.classList.toggle('dark-mode');
            localStorage.setItem('mp3PlayerDarkMode', body.classList.contains('dark-mode'));
            updateAccentColors(); // Call updateAccentColors to re-evaluate based on new dark mode state
        });

        dynamicAccentToggle.addEventListener('change', () => {
            localStorage.setItem('mp3PlayerDynamicAccent', dynamicAccentToggle.checked);
            updateAccentColors(); // Re-evaluate and apply accent colors based on the toggle state
        });

        accentColorButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Fix: Access dataset properties in camelCase
                const color = button.dataset.accentColor;
                localStorage.setItem('mp3PlayerAccentColor', color); // Save selected static color
                updateAccentColors(); // Apply colors (will use static if dynamic is off)
            });
        });

        // Playback Speed Control Logic
        playbackSpeedBar.addEventListener('input', () => {
            // Convert slider value (5-20) to playback rate (0.5-2.0)
            const speed = (parseInt(playbackSpeedBar.value) / 10).toFixed(1);
            audioPlayer.playbackRate = speed;
            playbackSpeedValue.textContent = `${speed}x`;
            localStorage.setItem('mp3PlayerPlaybackSpeed', speed); // Persist speed
        });

        // Event Listener for AI Features Dropdown Toggle
        aiFeaturesToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent this click from immediately closing the dropdown via document listener
            aiFeaturesDropdownMenu.classList.toggle('hidden');
        });

        // Global click listener to hide context menu AND AI dropdown
        document.addEventListener('click', (e) => {
            // Hide custom song context menu
            if (!customContextMenu.contains(e.target) && !e.target.closest('[data-song-id]')) {
                hideContextMenu();
            }
            // Hide playlist context menu
            if (!playlistContextMenu.contains(e.target) && !e.target.closest('[data-playlist-id]')) {
                hidePlaylistContextMenu();
            }
            // Hide AI features dropdown
            if (!aiFeaturesDropdownMenu.contains(e.target) && e.target !== aiFeaturesToggleBtn) {
                aiFeaturesDropdownMenu.classList.add('hidden');
            }
            // Hide playlist creation modal if clicked outside
            if (!createPlaylistModal.classList.contains('hidden') && !createPlaylistModal.querySelector('.modal-content').contains(e.target) && e.target !== createNewPlaylistBtn && e.target !== editPlaylistBtn) {
                hideCreatePlaylistModal();
            }
        });

        // Global right-click listener to hide context menu if clicking outside playlist items
        document.addEventListener('contextmenu', (e) => {
            if (!e.target.closest('[data-song-id]')) {
                hideContextMenu();
            }
            if (!e.target.closest('[data-playlist-id]')) {
                hidePlaylistContextMenu();
            }
        });

        // Event Listener for song context menu actions
        customContextMenu.addEventListener('click', handleContextMenuAction);
        // Event Listener for playlist context menu actions
        playlistContextMenu.addEventListener('click', handlePlaylistContextMenuAction);

        // Event Listeners for Playlist Creation Modal
        createPlaylistSearchInput.addEventListener('input', filterSongsForPlaylistCreation);
        savePlaylistBtn.addEventListener('click', saveNewPlaylist);
        cancelCreatePlaylistBtn.addEventListener('click', hideCreatePlaylistModal);

        // Event Listeners for Playlist Detail View Buttons
        backToPlaylistsBtn.addEventListener('click', backToPlaylists);
        playPlaylistBtn.addEventListener('click', () => {
            const currentDetailPlaylistId = parseInt(playlistDetailView.dataset.playlistId);
            playSelectedPlaylist(currentDetailPlaylistId);
        });
        shufflePlaylistBtn.addEventListener('click', () => {
            const currentDetailPlaylistId = parseInt(playlistDetailView.dataset.playlistId);
            shuffleSelectedPlaylist(currentDetailPlaylistId);
        });
        editPlaylistBtn.addEventListener('click', () => {
            const currentDetailPlaylistId = parseInt(playlistDetailView.dataset.playlistId);
            showCreatePlaylistModal(currentDetailPlaylistId);
        });


        // Initialize the player and theme when the window loads
        window.onload = function() {
            initializeTheme();
            // Set initial volume
            audioPlayer.volume = volumeBar.value / 100;
            // Load and set initial playback speed
            const savedPlaybackSpeed = localStorage.getItem('mp3PlayerPlaybackSpeed') || '1.0';
            playbackSpeedBar.value = parseFloat(savedPlaybackSpeed) * 10; // Convert back for slider
            audioPlayer.playbackRate = parseFloat(savedPlaybackSpeed);
            playbackSpeedValue.textContent = `${savedPlaybackSpeed}x`;

            // If there are songs in the library, load the first one.
            if (originalPlaylistOrder.length > 0) {
                playlist = [...originalPlaylistOrder]; // Default playing queue to full library
                loadSong();
            } else {
                loadSong(); // Load empty state if no songs
            }
            renderPlaylists(); // Render any saved playlists
        };
    </script>
</body>
</html>
